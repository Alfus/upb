"""TODO(haberman): Write module docstring."""

# begin:google_only
# load("//tools/build_defs/proto:proto_common.bzl", _proto_common = "proto_common")
#
# proto_common = _proto_common
# proto_lang_toolchain = native.proto_lang_toolchain
# end:google_only

def _declare_generated_files_polyfill(
        actions,
        proto_info,
        extension):
    """Declares generated files with a specific extension.

    Use this in lang_proto_library-es when protocol compiler generates files
    that correspond to .proto file names.

    The function removes ".proto" extension with given one (e.g. ".pb.cc") and
    declares new output files.

    Args:
      actions: (ActionFactory) Obtained by ctx.actions, used to declare the files.
      proto_info: (ProtoInfo) The ProtoInfo to declare the files for.
      extension: (str) The extension to use for generated files.

    Returns:
      (list[File]) The list of declared files.
    """
    proto_sources = proto_info.direct_sources
    outputs = []

    for src in proto_sources:
        basename_no_ext = src.basename[:-(len(src.extension) + 1)]

        # Note that two proto_library rules can have the same source file, so this is actually a
        # shared action. NB: This can probably result in action conflicts if the proto_library rules
        # are not the same.
        outputs.append(actions.declare_file(basename_no_ext + extension, sibling = src))

    return outputs

def _get_real_short_path(file):
    # For some reason, files from other archives have short paths that look like:
    #   ../com_google_protobuf/google/protobuf/descriptor.proto
    short_path = file.short_path
    if short_path.startswith("../"):
        second_slash = short_path.index("/", 3)
        short_path = short_path[second_slash + 1:]

    # Sometimes it has another few prefixes like:
    #   _virtual_imports/any_proto/google/protobuf/any.proto
    #   benchmarks/_virtual_imports/100_msgs_proto/benchmarks/100_msgs.proto
    # We want just google/protobuf/any.proto.
    virtual_imports = "_virtual_imports/"
    if virtual_imports in short_path:
        short_path = short_path.split(virtual_imports)[1].split("/", 1)[1]
    return short_path

def _proto_path_flag(path):
    if path == ".":
        return None
    return "--proto_path=%s" % path

def _compile_polyfill(
        actions,
        proto_info,
        proto_lang_toolchain_info,
        generated_files,
        plugin_output):
    """Creates proto compile action for compiling *.proto files to language specific sources.

    Args:
      actions: (ActionFactory)  Obtained by ctx.actions, used to register the actions.
      proto_info: (ProtoInfo) The ProtoInfo from proto_library to generate the sources for.
      proto_lang_toolchain_info: (ProtoLangToolchainInfo) The proto lang toolchain info.
        Obtained from a `proto_lang_toolchain` target or constructed ad-hoc..
      generated_files: (list[File]) The output files generated by the proto compiler.
        Callee needs to declare files using `ctx.actions.declare_file`.
        See also: `proto_common.declare_generated_files`.
      plugin_output: (File|str) The file or directory passed to the plugin.
        Formatted with `proto_lang_toolchain.out_replacement_format_flag`
    """

    args = actions.args()
    args.use_param_file(param_file_arg = "@%s")
    args.set_param_file_format("multiline")

    args.add(plugin_output, format = proto_lang_toolchain_info.out_replacement_format_flag)
    args.add(proto_lang_toolchain_info.plugin.executable, format = proto_lang_toolchain_info.plugin_format_flag)

    args.add_all(proto_info.transitive_proto_path, map_each = _proto_path_flag)
    # Example: `--proto_path=--proto_path=bazel-bin/target/third_party/pkg/_virtual_imports/subpkg`

    args.add_all(proto_lang_toolchain_info.protoc_opts)
    args.add("--descriptor_set_in=" + ":".join([f.path for f in proto_info.transitive_descriptor_sets.to_list()]))

    # Include maps
    # For each import, include both the import as well as the import relativized against its
    # protoSourceRoot. This ensures that protos can reference either the full path or the short
    # path when including other protos.
    #args.add_all(proto_info.transitive_descriptor_sets, map_each = _Iimport_path_equals_fullpath)
    # Example: `-Ia.proto=bazel-bin/target/third_party/pkg/_virtual_imports/subpkg/a.proto`

    args.add_all(proto_info.direct_sources, map_each = _get_real_short_path)

    actions.run(
        mnemonic = proto_lang_toolchain_info.mnemonic,
        progress_message = proto_lang_toolchain_info.progress_message,
        executable = proto_lang_toolchain_info.proto_compiler,
        arguments = [args],
        inputs = depset(
            direct = [proto_info.direct_descriptor_set],
            transitive = [proto_info.transitive_descriptor_sets],
        ),
        outputs = generated_files,
        tools = [proto_lang_toolchain_info.plugin],
        use_default_shell_env = True,
    )

## Polyfill for proto_lang_toolchain() and ProtoLangToolchainInfo.

_ProtoLangToolchainPolyfillInfo = provider(
    "A polyfill for ProtoLangToolchainInfo",
    fields = [
        "out_replacement_format_flag",
        "plugin_format_flag",
        "plugin",
        "runtime",
        "proto_compiler",
        "protoc_opts",
        "progress_message",
        "mnemonic",
    ],
)

def _proto_lang_toolchain_polyfill_impl(ctx):
    return [
        DefaultInfo(
            files = depset(),
            runfiles = ctx.runfiles(),
        ),
        _ProtoLangToolchainPolyfillInfo(
            out_replacement_format_flag = ctx.attr.command_line,
            plugin_format_flag = ctx.attr.plugin_format_flag,
            plugin = ctx.attr.plugin[DefaultInfo].files_to_run,
            runtime = ctx.attr.runtime,
            proto_compiler = ctx.attr._proto_compiler.files_to_run,
            protoc_opts = ctx.fragments.proto.experimental_protoc_opts,
            progress_message = ctx.attr.progress_message,
            mnemonic = ctx.attr.mnemonic,
        ),
    ]

_proto_lang_toolchain_polyfill = rule(
    implementation = _proto_lang_toolchain_polyfill_impl,
    attrs = {
        "progress_message": attr.string(default = "Generating proto_library %{label}"),
        "mnemonic": attr.string(default = "GenProto"),
        "command_line": attr.string(mandatory = True),
        "plugin_format_flag": attr.string(),
        "plugin": attr.label(
            executable = True,
            cfg = "exec",
        ),
        "runtime": attr.label(),
        "_proto_compiler": attr.label(
            cfg = "exec",
            executable = True,
            allow_files = True,
            default = configuration_field("proto", "proto_compiler"),
        ),
    },
    provides = [_ProtoLangToolchainPolyfillInfo],
    fragments = ["proto"],
)

## Top Level: exports proto_common and proto_lang_toolchain()

# begin:github_only
proto_common = struct(
    compile = _compile_polyfill,
    declare_generated_files = _declare_generated_files_polyfill,
    ProtoLangToolchainInfo = _ProtoLangToolchainPolyfillInfo,
)
proto_lang_toolchain = _proto_lang_toolchain_polyfill
# end:github_only
